var g=Object.defineProperty;var u=(h,t,a)=>t in h?g(h,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):h[t]=a;var e=(h,t,a)=>u(h,typeof t!="symbol"?t+"":t,a);import{G as w}from"./lil-gui.esm-hsJpI9MV.js";import{B as p}from"./BaseDemo-DB1y7toB.js";import{A as l}from"./AnimationTimer-DJQ6xzIw.js";import{S as r}from"./Sprite-9nB6cOPC.js";class d extends p{constructor(a){super(a);e(this,"name","时间动画-缓动函数");e(this,"ball");e(this,"ledge");e(this,"ballMoveBehavior");e(this,"pushAnimationTimer",new l(3e3));e(this,"animationFnMap",{linear:l.linear(),easeIn:l.easeIn(2),easeOut:l.easeOut(2),easeInOut:l.easeInOut(),elastic:l.elastic(4),bounce:l.bounce(4)});e(this,"config",{trace:!1,animationFn:"linear",restartAnimation:()=>this.restartAnimationTimer()});this.canvas=a,this.pushAnimationTimer.setTimeWarp(this.animationFnMap[this.config.animationFn]),this.createControl().initSprite()}static init(a){return new d(a)}createControl(){const{config:a}=this;this.gui=new w;const{gui:i}=this;return i.add(a,"trace"),i.add(a,"animationFn",Object.keys(this.animationFnMap)).onFinishChange(s=>{this.pushAnimationTimer.setTimeWarp(this.animationFnMap[s])}),i.add(a,"restartAnimation"),this}draw(a){return this.clearScreen().drawGrid().drawScene(a)}initSprite(){const{pushAnimationTimer:a}=this;return this.ball=new r("ball",{paint:(i,s)=>this.paintBall(i,s)}),this.ledge=new r("ledge",{paint(i,s){s.save(),s.shadowColor="rgba(0,0,0,0.8)",s.shadowBlur=8,s.shadowOffsetX=4,s.shadowOffsetY=4,s.fillStyle="rgba(255,255,0,0.6)",s.fillRect(i.x,i.y,i.width,i.height),s.restore()}}),this.ballMoveBehavior=new f(this.ball,this.ledge,a),this.ball.addBehavior(this.ballMoveBehavior),this.ledge.x=200,this.ledge.y=this.height/2,this.ledge.height=5,this.ledge.width=this.width-this.ledge.x*2,this.ball.width=50,this.ball.height=50,this.ball.x=this.ledge.x+this.ball.width/2,this.ball.y=this.ledge.y-this.ball.width/2,this.ball.velocityX=100,this.ball.velocityY=0,this}drawScene(a){const{context:i,config:s,ball:n,ledge:o,ballMoveBehavior:m}=this;return n.update(i,a),n.paint(i),o.update(i,a),o.paint(i),s.trace&&m.ballLocations.forEach(b=>{this.paintBall(n,i,b)}),this}restartAnimationTimer(){const{pushAnimationTimer:a,ballMoveBehavior:i}=this;i.ballLocations=[],a.isRunning()&&a.stop(),a.start()}paintBall(a,i,s){i.save(),i.beginPath(),i.arc(s||a.x,a.y,a.width/2,0,Math.PI*2,!1),i.clip(),i.shadowColor="rgb(0,0,255)",i.shadowOffsetX=-4,i.shadowOffsetY=-4,i.shadowBlur=8,i.lineWidth=2,i.strokeStyle="rgb(100,100,195)",i.stroke(),i.beginPath(),i.arc(s||a.x,a.y,a.width/2/2,0,Math.PI*2,!1),i.clip(),i.shadowColor="rgb(255,255,0)",i.shadowOffsetX=-4,i.shadowOffsetY=-4,i.shadowBlur=8,i.stroke(),i.restore()}}class f{constructor(t,a,i){e(this,"lastTime");e(this,"ballLocations",[]);this.ball=t,this.ledge=a,this.pushAnimationTimer=i}isBallOnLedge(){const{ball:t,ledge:a}=this;return t.x+t.width>a.x&&t.x<a.x+a.width}resetBall(){this.ballLocations=[],this.ball.x=this.ledge.x+this.ball.width/2,this.ball.y=this.ledge.y-this.ball.width/2}updateBallPosition(t){const{ball:a}=this;a.x+=a.velocityX*(t/1e3)}execute(t,a,i){const{pushAnimationTimer:s}=this,n=s.getElapsedTime();let o=0;s.isRunning()&&this.lastTime!==void 0&&(o=n-this.lastTime,this.updateBallPosition(o),this.ballLocations.push(t.x),this.isBallOnLedge()?s.isOver()&&(s.stop(),this.ballLocations=[]):(s.stop(),this.resetBall())),this.lastTime=n}}export{d as Demo,f as MoveBallBehavior};
