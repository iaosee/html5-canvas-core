import{G as d}from"./lil-gui.esm-hsJpI9MV.js";import{S as u}from"./stats.min-BpIepu9J.js";import{B as y}from"./BaseDemo-CScLeyCm.js";class h extends y{constructor(o){super(o),this.name="绘制动态三角网格",this.pointOfLine=[],this.triangleOfLine=[],this.lastTime=0,this.config={animation:!0,drawBoundary:!1,count:10},this.context.lineCap="round",this.context.lineJoin="round",this.createControl().initStats().initDotLine().initTriangleLine()}static init(o){return new h(o)}createControl(){const{config:o}=this;this.gui=new d;const{gui:i}=this;return i.add(o,"animation"),i.add(o,"drawBoundary"),i.add(o,"count").min(5).max(30).onFinishChange(e=>{this.pointOfLine=[],this.triangleOfLine=[],this.initDotLine().initTriangleLine()}),this}initStats(){return this.stats=new u,this.stats.showPanel(0),document.body.appendChild(this.stats.dom),this}draw(o){return this.stats.update(),this.lastTime=o,this.clearScreen().drawGrid().updatePosition().drawScene(o)}initDotLine(){const{context:o,config:i}=this,e=this.width,r=this.height,n=r/i.count;let t=!1;for(let s=n/2;s<=r;s+=n){const a=[];t=!t;for(let l=n/2;l<=e-50;l+=n){const c={boundary:{left:l+(t?n/2:0)-n/2,top:s-n/2,right:l+(t?n/2:0)+n/2,bottom:s+n/2},x:l+(t?n/2:0)+(Math.random()*.8-.4)*n,y:s+(Math.random()*.8-.4)*n,velocityX:Math.random()*.8-.4,velocityY:Math.random()*.8-.4};a.push(c)}this.pointOfLine.push(a)}return this}initTriangleLine(){const{context:o,pointOfLine:i}=this;let e=!0;for(let r=0;r<i.length-1;r++){e=!e;const n=[];for(let t=0;t<i[r].length;t++){const s=e?i[r][t]:i[r+1][t],a=e?i[r+1][t]:i[r][t];s.color=this.randomRgba(),a.color=this.randomRgba(),n.push(s,a)}this.triangleOfLine.push(n)}return this}drawScene(o){return this.triangleOfLine.map(i=>{for(let e=0;e<i.length-2;e++)this.drawTriangle(i[e],i[e+1],i[e+2])}),this}updatePosition(){const{config:o,context:i,pointOfLine:e}=this;if(!o.animation)return this;for(let r=0;r<e.length;r++)for(let n=0;n<e[r].length;n++){const t=e[r][n];(t.x+t.velocityX>t.boundary.right||t.x+t.velocityX<t.boundary.left)&&(t.velocityX=-t.velocityX),(t.y+t.velocityY>t.boundary.bottom||t.y+t.velocityY<t.boundary.top)&&(t.velocityY=-t.velocityY),t.x+=t.velocityX,t.y+=t.velocityY,o.drawBoundary&&(i.save(),i.beginPath(),i.strokeStyle="rgba(255,0,0,0.6)",i.moveTo(t.boundary.left,t.boundary.top),i.lineTo(t.boundary.left,t.boundary.bottom),i.lineTo(t.boundary.right,t.boundary.bottom),i.lineTo(t.boundary.right,t.boundary.top),i.lineTo(t.boundary.left,t.boundary.top),i.stroke(),i.closePath(),i.restore())}return this}drawTriangle(o,i,e,r){const{context:n,config:t}=this;return n.save(),n.fillStyle=r||e.color,n.beginPath(),n.moveTo(o.x,o.y),n.lineTo(i.x,i.y),n.lineTo(e.x,e.y),n.lineTo(o.x,o.y),n.closePath(),n.stroke(),n.fill(),n.restore(),this}}export{h as Demo};
