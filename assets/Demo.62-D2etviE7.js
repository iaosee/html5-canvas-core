var M=Object.defineProperty;var S=(x,l,i)=>l in x?M(x,l,{enumerable:!0,configurable:!0,writable:!0,value:i}):x[l]=i;var c=(x,l,i)=>S(x,typeof l!="symbol"?l+"":l,i);import{G as C}from"./lil-gui.esm-hsJpI9MV.js";import{B as V,P as r}from"./BaseDemo-DB1y7toB.js";import{R as b}from"./index-Bp5GyCed.js";import{P as f,C as w,V as d}from"./Polygon-DGNxmrap.js";import{C as k}from"./CircleImage-CUqYqt57.js";import{R as B}from"./RandomConvexPolygon-DHYIvaIw.js";import{g as T}from"./golfball-fqIsnLt-.js";class m extends V{constructor(i){super(i);c(this,"name","碰撞检测 — 最小平移向量");c(this,"shapes",[]);c(this,"lastTime",0);c(this,"isStuck",!1);c(this,"shapeMoving");c(this,"velocity",{x:350,y:250});c(this,"lastVelocity",{x:350,y:250});c(this,"mousedownPos",new r(0,0));c(this,"mousemovePos",new r(0,0));c(this,"randomPolygon",new B({maxWidth:200,maxHeight:200}));c(this,"polygonPoints",[[new r(100,100),new r(100,200),new r(200,200)],[new r(300,100),new r(300,200),new r(400,200),new r(400,100)],[new r(500,100),new r(475,200),new r(600,200),new r(625,100)]]);c(this,"config",{boundingBox:!1,count:10});this.canvas=i,this.createControl().initShapes().listenEvents()}static init(i){return new m(i)}createControl(){const{velocity:i,config:n}=this;this.gui=new C;const{gui:t}=this;return t.add(n,"boundingBox").onFinishChange(o=>this.drawScene()),t.add(i,"x").min(10).max(1500).onFinishChange(o=>this.velocity.x=Number(o)),t.add(i,"y").min(10).max(1500).onFinishChange(o=>this.velocity.y=Number(o)),this}draw(i=0){const{shapeMoving:n,velocity:t}=this;if(this.lastTime||(this.lastTime=i),n){const o=i-this.lastTime,s=t.x*(o/1e3),e=t.y*(o/1e3);n.move(s,e),this.handleEdgeCollisions().handleShapeCollisions()}return this.drawScene(),this.lastTime=i,this}initShapes(){const{polygonPoints:i}=this,n=this.polygonPoints.length;for(let t=0;t<n;++t){const o=new f,s=i[t];o.setPoints(s),o.name=`Polygon ${t}`,o.strokeStyle=this.randomRgba(),o.fillStyle=this.randomRgba(),this.shapes.push(o)}for(let t=0;t<2;t++)for(let o=0;o<3;o++){const s=this.randomPolygon.getConvex(b.init(4,10).random()),e=new f;e.setPoints(s),e.move(o*300,(t+1)*300),e.name=`Polygon ${t}-${o}`,e.strokeStyle=this.randomRgba(),e.fillStyle=this.randomRgba(),this.shapes.push(e)}return this.shapes.push(new w({name:"circle 1",x:100,y:50,radius:30})),this.shapes.push(new w({name:"circle 2",x:250,y:50,radius:50})),this.shapes.push(new k({name:"circleImage",x:800,y:100,radius:72,strokeStyle:"red",imageSource:T})),this}drawShapes(){const{context:i,config:n}=this;return this.shapes.forEach(t=>{if(t.stroke(i),t.fill(i),n.boundingBox){const o=t.getBoundingBox();i.strokeRect(o.x,o.y,o.width,o.height)}}),this}drawScene(){return this.clearScreen().drawGrid().drawShapes(),this}detectCollisions(){const{context:i,shapes:n,shapeMoving:t,velocity:o}=this;let s=30;if(!t)return this;i.save(),i.font="20px Palatino",n.forEach(h=>{if(h===t)return;const a=t.collidesMTVWith(h);(a.axis||a.overlap)&&(i.lineWidth=10,i.fillStyle="red",i.strokeStyle="red",i.fillText(`${t.name} Collision with ${h.name}`,20,s),i.strokeRect(0,0,this.width,this.height),s+=40,!this.isStuck&&this.stick(a))}),i.restore();const e=t==null?void 0:t.getBoundingBox();return(e.x+e.width>this.width||e.x<0)&&(o.x=-o.x),(e.y+e.height>this.height||e.y<0)&&(o.y=-o.y),this}stick(i){const{shapeMoving:n,velocity:t,lastVelocity:o}=this;if(!i.axis){const h=new r,a=Math.sqrt(Math.pow(t.x,2)+Math.pow(t.y,2));h.x=t.x/a,h.y=t.y/a,i.axis=new d(h.x,h.y)}let s=i.axis.x*(i.overlap+2),e=i.axis.y*(i.overlap+2);(s<0&&t.x<0||s>0&&t.x>0)&&(s=-s),(e<0&&t.y<0||e>0&&t.y>0)&&(e=-e),setTimeout(()=>{n.move(s,e)},500),o.x=t.x,o.y=t.y,t.x=t.y=0,this.isStuck=!0}separate(i){const{shapeMoving:n,velocity:t,lastVelocity:o}=this;let s,e,h,a;i.axis||(a=new r,h=Math.sqrt(Math.pow(t.x,2)+Math.pow(t.y,2)),a.x=t.x/h,a.y=t.y/h,i.axis=new d(a.x,a.y)),e=i.axis.y*i.overlap,s=i.axis.x*i.overlap,(s<0&&t.x<0||s>0&&t.x>0)&&(s=-s),(e<0&&t.y<0||e>0&&t.y>0)&&(e=-e),n.move(s,e)}checkMTVAxisDirection(i,n,t){if(!i.axis)return;const o=d.fromPoint(n.centroid()),e=d.fromPoint(t.centroid()).subtract(o);new d(e.x,e.y).normalize().dotProduct(i.axis)>0&&(i.axis.x=-i.axis.x,i.axis.y=-i.axis.y)}bounce(i,n,t){const{shapeMoving:o,velocity:s,lastVelocity:e}=this,h=new d(s.x,s.y),a=h.normalize(),y=h.getMagnitude();if(!o)return;this.checkMTVAxisDirection(i,n,t);const u=new r,g=i.axis?i.axis.perpendicular():new d(-a.y,a.x),v=a.dotProduct(g),P=g.dotProduct(g),p=v/P;u.x=2*p*g.x-a.x,u.y=2*p*g.y-a.y,this.separate(i),s.x=u.x*y,s.y=u.y*y}handleEdgeCollisions(){const{shapeMoving:i,velocity:n}=this,t=i.getBoundingBox(),o=t.x+t.width,s=t.y+t.height;return(o>this.width||t.x<0)&&(n.x=-n.x,o>this.width&&i.move(0-(o-this.width),0),t.x<0&&i.move(-t.x,0)),(s>this.height||t.y<0)&&(n.y=-n.y,s>this.height&&i.move(0,0-(s-this.height)),t.y<0&&i.move(0,-t.y)),this}handleShapeCollisions(){const{shapeMoving:i}=this;return this.shapes.forEach(n=>{if(n!==i){const t=i.collidesMTVWith(n);(t.axis||t.overlap)&&this.bounce(t,i,n)}}),this}listenEvents(){const{canvas:i,context:n,dpr:t,shapes:o,velocity:s,lastVelocity:e}=this;return i.addEventListener("mousedown",h=>{const a=this.coordinateTransformation(h.clientX,h.clientY);this.isStuck=!1,this.shapeMoving=void 0,o.forEach(y=>{y.isPointInPath(n,a.x*t,a.y*t)&&(this.shapeMoving=y)})}),this}}export{m as Demo};
