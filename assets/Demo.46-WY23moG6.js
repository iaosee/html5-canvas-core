var r=Object.defineProperty;var p=(n,a,t)=>a in n?r(n,a,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[a]=t;var e=(n,a,t)=>p(n,typeof a!="symbol"?a+"":a,t);import{G as l}from"./lil-gui.esm-hsJpI9MV.js";import{S as m}from"./stats.min-BpIepu9J.js";import{B as y}from"./BaseDemo-DB1y7toB.js";import{R as u}from"./index-D3O5bMvL.js";class h extends y{constructor(t){super(t);e(this,"name","动画 —— 帧率显示/基于时间动画");e(this,"circles",[]);e(this,"random",u.init(-5,5));e(this,"lastTime",0);e(this,"elapsedTime",0);e(this,"lastFpsUpdate",0);e(this,"lastFpsUpdateTime",0);e(this,"fps",0);e(this,"config",{timeBased:!1});this.canvas=t;const i={x:this.centerX,y:this.centerY};this.createControl().initStats().createCircle(i,50).listenEvents()}static init(t){return new h(t)}draw(t){const i=+new Date;this.elapsedTime=t-this.lastTime;const s=1e3/(t-this.lastTime);return this.fps=s,i-this.lastFpsUpdateTime>1e3&&(this.lastFpsUpdate=s,this.lastFpsUpdateTime=i),this.clearScreen().drawGrid().drawCircles().drawFpsLabel(this.lastFpsUpdate),this.stats.update(),this.lastTime=t,this}initStats(){return this.stats=new m,this.stats.showPanel(0),document.body.appendChild(this.stats.dom),this}createControl(){const{config:t}=this;this.gui=new l;const{gui:i}=this;return i.add(t,"timeBased"),this}createCircle(t,i=100,s=!1){s&&this.circles.splice(0,this.circles.length);for(let o=0;o<i;o++){const d={x:t.x||this.centerX,y:t.y||this.centerY};this.circles.push({position:d,velocityX:Math.random()*(this.random.range(-8,8).getOne()||8),velocityY:Math.random()*(this.random.range(-8,8).getOne()||8),radius:Math.random()*20,color:this.randomRgba()})}return this}drawCircles(){const{context:t,config:i}=this;return this.circles.forEach(s=>{t.beginPath(),t.arc(s.position.x,s.position.y,s.radius,0,Math.PI*2,!1),t.fillStyle=s.color,t.fill(),i.timeBased?this.updatePositionByTime(s):this.updatePosition(s)}),this}updatePosition(t){const{canvas:i}=this;return(t.position.x+t.velocityX+t.radius>i.width||t.position.x+t.velocityX-t.radius<0)&&(t.velocityX=-t.velocityX),(t.position.y+t.velocityY+t.radius>i.height||t.position.y+t.velocityY-t.radius<0)&&(t.velocityY=-t.velocityY),t.position.x+=t.velocityX,t.position.y+=t.velocityY,this}updatePositionByTime(t){const{canvas:i}=this;let s=t.velocityX/this.fps*10,o=t.velocityY/this.fps*10;return(t.position.x+s+t.radius>i.width||t.position.x+s-t.radius<0)&&(t.velocityX=-t.velocityX,s=-s),(t.position.y+o+t.radius>i.height||t.position.y+o-t.radius<0)&&(t.velocityY=-t.velocityY,o=-o),t.position.x+=s,t.position.y+=o,this}listenEvents(){const{canvas:t}=this,i=s=>{const o=this.coordinateTransformation(s.clientX,s.clientY);s.type==="click"&&this.circles.splice(0,Math.floor(this.circles.length/2)),this.createCircle(o,100,!1)};t.addEventListener("mousemove",this.throttle(i,100),!1),t.addEventListener("click",i,!1)}}export{h as Demo};
