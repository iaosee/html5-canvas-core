var b=Object.defineProperty;var g=(h,t,i)=>t in h?b(h,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):h[t]=i;var e=(h,t,i)=>(g(h,typeof t!="symbol"?t+"":t,i),i);import{G as w}from"./lil-gui.esm.7a5dd4ff.js";import{B as p}from"./BaseDemo.9c35b300.js";import{A as l}from"./AnimationTimer.e9c92d46.js";import{S as r}from"./Sprite.b43779c9.js";class d extends p{constructor(i){super(i);e(this,"name","\u65F6\u95F4\u52A8\u753B-\u7F13\u52A8\u51FD\u6570");e(this,"ball");e(this,"ledge");e(this,"ballMoveBehavior");e(this,"pushAnimationTimer",new l(3e3));e(this,"animationFnMap",{linear:l.linear(),easeIn:l.easeIn(2),easeOut:l.easeOut(2),easeInOut:l.easeInOut(),elastic:l.elastic(4),bounce:l.bounce(4)});e(this,"config",{trace:!1,animationFn:"linear",restartAnimation:()=>this.restartAnimationTimer()});this.canvas=i,this.pushAnimationTimer.setTimeWarp(this.animationFnMap[this.config.animationFn]),this.createControl().initSprite()}static init(i){return new d(i)}createControl(){const{config:i}=this;this.gui=new w;const{gui:a}=this;return a.add(i,"trace"),a.add(i,"animationFn",Object.keys(this.animationFnMap)).onFinishChange(s=>{this.pushAnimationTimer.setTimeWarp(this.animationFnMap[s])}),a.add(i,"restartAnimation"),this}draw(i){return this.clearScreen().drawGrid().drawScene(i)}initSprite(){const{pushAnimationTimer:i}=this;return this.ball=new r("ball",{paint:(a,s)=>this.paintBall(a,s)}),this.ledge=new r("ledge",{paint(a,s){s.save(),s.shadowColor="rgba(0,0,0,0.8)",s.shadowBlur=8,s.shadowOffsetX=4,s.shadowOffsetY=4,s.fillStyle="rgba(255,255,0,0.6)",s.fillRect(a.x,a.y,a.width,a.height),s.restore()}}),this.ballMoveBehavior=new f(this.ball,this.ledge,i),this.ball.addBehavior(this.ballMoveBehavior),this.ledge.x=200,this.ledge.y=this.height/2,this.ledge.height=5,this.ledge.width=this.width-this.ledge.x*2,this.ball.width=50,this.ball.height=50,this.ball.x=this.ledge.x+this.ball.width/2,this.ball.y=this.ledge.y-this.ball.width/2,this.ball.velocityX=100,this.ball.velocityY=0,this}drawScene(i){const{context:a,config:s,ball:n,ledge:o,ballMoveBehavior:m}=this;return n.update(a,i),n.paint(a),o.update(a,i),o.paint(a),s.trace&&m.ballLocations.forEach(u=>{this.paintBall(n,a,u)}),this}restartAnimationTimer(){const{pushAnimationTimer:i,ballMoveBehavior:a}=this;a.ballLocations=[],i.isRunning()&&i.stop(),i.start()}paintBall(i,a,s){a.save(),a.beginPath(),a.arc(s||i.x,i.y,i.width/2,0,Math.PI*2,!1),a.clip(),a.shadowColor="rgb(0,0,255)",a.shadowOffsetX=-4,a.shadowOffsetY=-4,a.shadowBlur=8,a.lineWidth=2,a.strokeStyle="rgb(100,100,195)",a.stroke(),a.beginPath(),a.arc(s||i.x,i.y,i.width/2/2,0,Math.PI*2,!1),a.clip(),a.shadowColor="rgb(255,255,0)",a.shadowOffsetX=-4,a.shadowOffsetY=-4,a.shadowBlur=8,a.stroke(),a.restore()}}class f{constructor(t,i,a){e(this,"lastTime");e(this,"ballLocations",[]);this.ball=t,this.ledge=i,this.pushAnimationTimer=a}isBallOnLedge(){const{ball:t,ledge:i}=this;return t.x+t.width>i.x&&t.x<i.x+i.width}resetBall(){this.ballLocations=[],this.ball.x=this.ledge.x+this.ball.width/2,this.ball.y=this.ledge.y-this.ball.width/2}updateBallPosition(t){const{ball:i}=this;i.x+=i.velocityX*(t/1e3)}execute(t,i,a){const{pushAnimationTimer:s}=this,n=s.getElapsedTime();let o=0;s.isRunning()&&this.lastTime!==void 0&&(o=n-this.lastTime,this.updateBallPosition(o),this.ballLocations.push(t.x),this.isBallOnLedge()?s.isOver()&&(s.stop(),this.ballLocations=[]):(s.stop(),this.resetBall())),this.lastTime=n}}export{d as Demo,f as MoveBallBehavior};
