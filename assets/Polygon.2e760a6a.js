var A=Object.defineProperty;var S=(r,t,s)=>t in r?A(r,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):r[t]=s;var a=(r,t,s)=>(S(r,typeof t!="symbol"?t+"":t,s),s);import{P as u}from"./BaseDemo.9c35b300.js";class h{constructor(t,s){a(this,"x");a(this,"y");this.x=t||0,this.y=s||0}static fromPoint(t){return new h(t.x,t.y)}equals(t){return this.x===t.x&&this.y===t.y}getMagnitude(){return Math.sqrt(Math.pow(this.x,2)+Math.pow(this.y,2))}add(t){return new h(this.x+t.x,this.y+t.y)}subtract(t){return new h(this.x-t.x,this.y-t.y)}dotProduct(t){return this.x*t.x+this.y*t.y}edge(t){return this.subtract(t)}perpendicular(){return new h(this.y,0-this.x)}normalize(){const t=this.getMagnitude();return new h(this.x/t,this.y/t)}normal(){return this.perpendicular().normalize()}reflect(t){const s=this.dotProduct(t),i=t.dotProduct(t),e=s/i;return new h(2*e*t.x-this.x,2*e*t.y-this.y)}}class v{constructor(t,s){a(this,"min");a(this,"max");this.min=t,this.max=s}overlaps(t){return this.max>t.min&&t.max>this.min}getOverlap(t){if(!this.overlaps(t))return 0;let s;return this.max>t.max?s=t.max-this.min:s=this.max-t.min,s}}class c{constructor(t,s){a(this,"axis");a(this,"overlap");this.axis=t,this.overlap=s}}function w(r,t,s){const i=new h(r.x,r.y),e=new h(t.x,t.y);return i.subtract(e).normalize()}function p(r,t){let s=1e6,i;for(var e=0;e<r.points.length;++e){const n=r.points[e],o=n.distance(new u(t.x,t.y));o<s&&(s=o,i=n)}return i}function P(r,t){const s=r.getAxes(),i=p(r,t),e=new h(t.x,t.y),n=new h(i.x,i.y);return s.push(e.subtract(n).normalize()),!r.separationOnAxes(s,t)}function g(r,t){const s=Math.sqrt(Math.pow(t.x-r.x,2)+Math.pow(t.y-r.y,2)),i=Math.abs(r.radius+t.radius)-s;return i<0?new c(void 0,0):new c(void 0,i)}function f(r,t,s){const i=r.minimumTranslationVector(r.getAxes(),t,s),e=r.minimumTranslationVector(t.getAxes(),t,s);return i.overlap===0||e.overlap===0?new c(void 0,0):i.overlap<e.overlap?i:e}const T=1e6;class M{constructor(t){a(this,"name");a(this,"x");a(this,"y");a(this,"fillStyle","rgba(147, 197, 114, 0.8)");a(this,"strokeStyle","rgba(255, 253, 208, 0.9)");this.x=t==null?void 0:t.x,this.y=t==null?void 0:t.y,this.name=t==null?void 0:t.name,this.fillStyle=(t==null?void 0:t.fillStyle)||this.fillStyle,this.strokeStyle=(t==null?void 0:t.strokeStyle)||this.strokeStyle}getPosition(){return{x:this.x,y:this.y}}setPosition(t,s){return this.x=t,this.y=s,this}fill(t){return t.save(),t.fillStyle=this.fillStyle,this.createPath(t),t.fill(),t.restore(),this}stroke(t){return t.save(),t.strokeStyle=this.strokeStyle,this.createPath(t),t.stroke(),t.restore(),this}isPointInPath(t,s,i){return this.createPath(t),t.isPointInPath(s,i)}collidesWith(t){const s=this.getAxes().concat(t.getAxes());return!this.separationOnAxes(s,t)}separationOnAxes(t,s){for(let i=0,e=t.length;i<e;i++){const n=t[i],o=s.project(n),l=this.project(n);if(!o.overlaps(l))return!0}return!1}minimumTranslationVector(t,s,i){let e=T,n;for(var o=0;o<t.length;++o){const l=t[o],y=this.project(l),m=s.project(l),x=y.getOverlap(m);if(x===0)return new c(void 0,0);x<e&&(e=x,n=l)}return new c(n,e)}}class d extends M{constructor(s){super(s);a(this,"radius");this.radius=s==null?void 0:s.radius}collidesWith(s){return s.getAxes()===void 0&&s instanceof d?Math.sqrt(Math.pow(s.x-this.x,2)+Math.pow(s.y-this.y,2))<Math.abs(this.radius+s.radius):P(s,this)}collidesMTVWith(s,i){if(s instanceof b){const e=s.getAxes(),n=p(s,this);return e.push(w(this,n)),s.minimumTranslationVector(e,this,i)}return g(this,s)}getAxes(){}project(s){const i=[],e=new u(this.x,this.y),n=new h(e.x,e.y).dotProduct(s);return i.push(n),i.push(n+this.radius),i.push(n-this.radius),new v(Math.min.apply(Math,i),Math.max.apply(Math,i))}move(s,i){this.x+=s,this.y+=i}createPath(s){s.beginPath(),s.arc(this.x,this.y,this.radius,0,Math.PI*2,!1)}centroid(){return new u(this.x,this.y)}getBoundingBox(){return{x:this.x-this.radius,y:this.y-this.radius,width:this.radius*2,height:this.radius*2}}}class b extends M{constructor(s){super(s);a(this,"points",[]);this.points=(s==null?void 0:s.points)||[]}addPoint(s,i){return this.points.push(new u(s,i)),this}setPoints(s){return this.points=[].concat(s),this}move(s,i){const e=this.points.length;for(var n=0;n<e;++n)this.points[n].move(s,i);return this}createPath(s){if(this.points.length!==0){s.beginPath(),s.moveTo(this.points[0].x,this.points[0].y);for(var i=1;i<this.points.length;++i)s.lineTo(this.points[i].x,this.points[i].y);return s.closePath(),this}}collidesWith(s){return s.getAxes()===void 0&&s instanceof d?P(this,s):super.collidesWith(s)}collidesMTVWith(s,i){if(s instanceof d){const e=this.getAxes(),n=p(this,s);return e.push(w(s,n)),this.minimumTranslationVector(e,s,i)}return f(this,s,i)}getAxes(){const s=[],i=this.points.length;for(let o=0;o<i-1;o++){const l=this.points[o],y=this.points[o+1],m=new h(l.x,l.y),x=new h(y.x,y.y);s.push(m.edge(x).normal())}const e=new h(this.points[i-1].x,this.points[i-1].y),n=new h(this.points[0].x,this.points[0].y);return s.push(e.edge(n).normal()),s}project(s){const i=[];return this.points.forEach(e=>{const n=new h(e.x,e.y);i.push(n.dotProduct(s))}),new v(Math.min.apply(Math,i),Math.max.apply(Math,i))}centroid(){const s=new u(0,0);for(let i=0;i<this.points.length;++i){const e=this.points[i];s.x+=e.x,s.y+=e.y}return new u(s.x/this.points.length,s.y/this.points.length)}getBoundingBox(){let s,i,e,n;return this.points.forEach(o=>{s===void 0&&(s=e=o.x,i=n=o.y),s=Math.min(s,o.x),i=Math.min(i,o.y),e=Math.max(e,o.x),n=Math.max(n,o.y)}),{x:s,y:i,width:e-s,height:n-i}}}export{d as C,b as P,h as V};
