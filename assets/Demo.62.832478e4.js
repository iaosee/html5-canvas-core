import{G as m}from"./lil-gui.esm.7a5dd4ff.js";import{B as v,P as r}from"./BaseDemo.deaf79c0.js";import{R as P}from"./index.c5f23cd0.js";import{P as u,C as g,V as c}from"./Polygon.fb0fffd3.js";import{C as S}from"./CircleImage.61806950.js";import{R as M}from"./RandomConvexPolygon.267444ef.js";import{g as C}from"./golfball.de451e99.js";class p extends v{constructor(i){super(i),this.canvas=i,this.name="\u78B0\u649E\u68C0\u6D4B \u2014 \u6700\u5C0F\u5E73\u79FB\u5411\u91CF",this.shapes=[],this.lastTime=0,this.isStuck=!1,this.velocity={x:350,y:250},this.lastVelocity={x:350,y:250},this.mousedownPos=new r(0,0),this.mousemovePos=new r(0,0),this.randomPolygon=new M({maxWidth:200,maxHeight:200}),this.polygonPoints=[[new r(100,100),new r(100,200),new r(200,200)],[new r(300,100),new r(300,200),new r(400,200),new r(400,100)],[new r(500,100),new r(475,200),new r(600,200),new r(625,100)]],this.config={boundingBox:!1,count:10},this.createControl().initShapes().listenEvents()}static init(i){return new p(i)}createControl(){const{velocity:i,config:n}=this;this.gui=new m;const{gui:t}=this;return t.add(n,"boundingBox").onFinishChange(o=>this.drawScene()),t.add(i,"x").min(10).max(1500).onFinishChange(o=>this.velocity.x=Number(o)),t.add(i,"y").min(10).max(1500).onFinishChange(o=>this.velocity.y=Number(o)),this}draw(i=0){const{shapeMoving:n,velocity:t}=this;if(this.lastTime||(this.lastTime=i),n){const o=i-this.lastTime,s=t.x*(o/1e3),e=t.y*(o/1e3);n.move(s,e),this.handleEdgeCollisions().handleShapeCollisions()}return this.drawScene(),this.lastTime=i,this}initShapes(){const{polygonPoints:i}=this,n=this.polygonPoints.length;for(let t=0;t<n;++t){const o=new u,s=i[t];o.setPoints(s),o.name=`Polygon ${t}`,o.strokeStyle=this.randomRgba(),o.fillStyle=this.randomRgba(),this.shapes.push(o)}for(let t=0;t<2;t++)for(let o=0;o<3;o++){const s=this.randomPolygon.getConvex(P.init(4,10).random()),e=new u;e.setPoints(s),e.move(o*300,(t+1)*300),e.name=`Polygon ${t}-${o}`,e.strokeStyle=this.randomRgba(),e.fillStyle=this.randomRgba(),this.shapes.push(e)}return this.shapes.push(new g({name:"circle 1",x:100,y:50,radius:30})),this.shapes.push(new g({name:"circle 2",x:250,y:50,radius:50})),this.shapes.push(new S({name:"circleImage",x:800,y:100,radius:72,strokeStyle:"red",imageSource:C})),this}drawShapes(){const{context:i,config:n}=this;return this.shapes.forEach(t=>{if(t.stroke(i),t.fill(i),n.boundingBox){const o=t.getBoundingBox();i.strokeRect(o.x,o.y,o.width,o.height)}}),this}drawScene(){return this.clearScreen().drawGrid().drawShapes(),this}detectCollisions(){const{context:i,shapes:n,shapeMoving:t,velocity:o}=this;let s=30;if(!t)return this;i.save(),i.font="20px Palatino",n.forEach(a=>{if(a===t)return;const h=t.collidesMTVWith(a);(h.axis||h.overlap)&&(i.lineWidth=10,i.fillStyle="red",i.strokeStyle="red",i.fillText(`${t.name} Collision with ${a.name}`,20,s),i.strokeRect(0,0,this.width,this.height),s+=40,!this.isStuck&&this.stick(h))}),i.restore();const e=t==null?void 0:t.getBoundingBox();return(e.x+e.width>this.width||e.x<0)&&(o.x=-o.x),(e.y+e.height>this.height||e.y<0)&&(o.y=-o.y),this}stick(i){const{shapeMoving:n,velocity:t,lastVelocity:o}=this;if(!i.axis){const a=new r,h=Math.sqrt(Math.pow(t.x,2)+Math.pow(t.y,2));a.x=t.x/h,a.y=t.y/h,i.axis=new c(a.x,a.y)}let s=i.axis.x*(i.overlap+2),e=i.axis.y*(i.overlap+2);(s<0&&t.x<0||s>0&&t.x>0)&&(s=-s),(e<0&&t.y<0||e>0&&t.y>0)&&(e=-e),setTimeout(()=>{n.move(s,e)},500),o.x=t.x,o.y=t.y,t.x=t.y=0,this.isStuck=!0}separate(i){const{shapeMoving:n,velocity:t,lastVelocity:o}=this;let s,e,a,h;i.axis||(h=new r,a=Math.sqrt(Math.pow(t.x,2)+Math.pow(t.y,2)),h.x=t.x/a,h.y=t.y/a,i.axis=new c(h.x,h.y)),e=i.axis.y*i.overlap,s=i.axis.x*i.overlap,(s<0&&t.x<0||s>0&&t.x>0)&&(s=-s),(e<0&&t.y<0||e>0&&t.y>0)&&(e=-e),n.move(s,e)}checkMTVAxisDirection(i,n,t){if(!i.axis)return;const o=c.fromPoint(n.centroid()),e=c.fromPoint(t.centroid()).subtract(o);new c(e.x,e.y).normalize().dotProduct(i.axis)>0&&(i.axis.x=-i.axis.x,i.axis.y=-i.axis.y)}bounce(i,n,t){const{shapeMoving:o,velocity:s,lastVelocity:e}=this,a=new c(s.x,s.y),h=a.normalize(),l=a.getMagnitude();if(!o)return;this.checkMTVAxisDirection(i,n,t);const x=new r,d=i.axis?i.axis.perpendicular():new c(-h.y,h.x),f=h.dotProduct(d),w=d.dotProduct(d),y=f/w;x.x=2*y*d.x-h.x,x.y=2*y*d.y-h.y,this.separate(i),s.x=x.x*l,s.y=x.y*l}handleEdgeCollisions(){const{shapeMoving:i,velocity:n}=this,t=i.getBoundingBox(),o=t.x+t.width,s=t.y+t.height;return(o>this.width||t.x<0)&&(n.x=-n.x,o>this.width&&i.move(0-(o-this.width),0),t.x<0&&i.move(-t.x,0)),(s>this.height||t.y<0)&&(n.y=-n.y,s>this.height&&i.move(0,0-(s-this.height)),t.y<0&&i.move(0,-t.y)),this}handleShapeCollisions(){const{shapeMoving:i}=this;return this.shapes.forEach(n=>{if(n!==i){const t=i.collidesMTVWith(n);(t.axis||t.overlap)&&this.bounce(t,i,n)}}),this}listenEvents(){const{canvas:i,context:n,dpr:t,shapes:o,velocity:s,lastVelocity:e}=this;return i.addEventListener("mousedown",a=>{const h=this.coordinateTransformation(a.clientX,a.clientY);this.isStuck=!1,this.shapeMoving=void 0,o.forEach(l=>{l.isPointInPath(n,h.x*t,h.y*t)&&(this.shapeMoving=l)})}),this}}export{p as Demo};
